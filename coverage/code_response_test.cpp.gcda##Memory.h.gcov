        -:    0:Source:/home/Arter/ABC2/src/Memory.h
        -:    0:Graph:/home/Arter/ABC2/Google_tests/CMakeFiles/Google_Tests_run.dir/code_response_test.cpp.gcno
        -:    0:Data:/home/Arter/ABC2/Google_tests/CMakeFiles/Google_Tests_run.dir/code_response_test.cpp.gcda
        -:    0:Runs:1
        -:    1:
        -:    2:#ifndef RISCV_SIM_DATAMEMORY_H
        -:    3:#define RISCV_SIM_DATAMEMORY_H
        -:    4:
        -:    5:#include "Instruction.h"
        -:    6:#include <iostream>
        -:    7:#include <fstream>
        -:    8:#include <elf.h>
        -:    9:#include <cstring>
        -:   10:#include <vector>
        -:   11:#include <cassert>
        -:   12:#include <map>
        -:   13:#include <list>
        -:   14:#include <algorithm>
        -:   15:
        -:   16:
        -:   17://static constexpr size_t memSize = 4*1024*1024; // memory size in 4-byte words
        -:   18:static constexpr size_t memSize = 1024 * 1024; // memory size in 4-byte words
        -:   19:
        -:   20:static constexpr size_t lineSizeBytes = 64;
        -:   21:static constexpr size_t lineSizeWords = lineSizeBytes / sizeof(Word);
        -:   22:using Line = std::array<Word, lineSizeWords>;
    #####:   23:static Word ToWordAddr(Word addr) { return addr >> 2u; }
    %%%%%:   23-block  0
        3:   24:static Word ToLineAddr(Word addr) { return addr & ~(lineSizeBytes - 1); }
        3:   24-block  0
    #####:   25:static Word ToLineOffset(Word addr) { return ToWordAddr(addr) & (lineSizeWords - 1); }
    %%%%%:   25-block  0
        -:   26:
        -:   27:class MemoryStorage {
        -:   28:public:
        -:   29:
    #####:   30:	MemoryStorage()
    #####:   31:	{
    %%%%%:   31-block  0
    $$$$$:   31-block  1
    #####:   32:		_mem.resize(memSize);
    #####:   33:	}
    %%%%%:   33-block  0
        -:   34:
        -:   35:	bool LoadElf(const std::string& elf_filename) {
        -:   36:		std::ifstream elffile;
        -:   37:		elffile.open(elf_filename, std::ios::in | std::ios::binary);
        -:   38:
        -:   39:		if (!elffile.is_open()) {
        -:   40:			std::cerr << "ERROR: load_elf: failed opening file \"" << elf_filename << "\"" << std::endl;
        -:   41:			return false;
        -:   42:		}
        -:   43:
        -:   44:		elffile.seekg(0, elffile.end);
        -:   45:		size_t buf_sz = elffile.tellg();
        -:   46:		elffile.seekg(0, elffile.beg);
        -:   47:
        -:   48:		// Read the entire file. If it doesn't fit in host memory, it won't fit in the risc-v processor
        -:   49:		std::vector<char> buf(buf_sz);
        -:   50:		elffile.read(buf.data(), buf_sz);
        -:   51:
        -:   52:		if (!elffile) {
        -:   53:			std::cerr << "ERROR: load_elf: failed reading elf header" << std::endl;
        -:   54:			return false;
        -:   55:		}
        -:   56:
        -:   57:		if (buf_sz < sizeof(Elf32_Ehdr)) {
        -:   58:			std::cerr << "ERROR: load_elf: file too small to be a valid elf file" << std::endl;
        -:   59:			return false;
        -:   60:		}
        -:   61:
        -:   62:		// make sure the header matches elf32 or elf64
        -:   63:		Elf32_Ehdr* ehdr = (Elf32_Ehdr*)buf.data();
        -:   64:		unsigned char* e_ident = ehdr->e_ident;
        -:   65:		if (e_ident[EI_MAG0] != ELFMAG0
        -:   66:			|| e_ident[EI_MAG1] != ELFMAG1
        -:   67:			|| e_ident[EI_MAG2] != ELFMAG2
        -:   68:			|| e_ident[EI_MAG3] != ELFMAG3) {
        -:   69:			std::cerr << "ERROR: load_elf: file is not an elf file" << std::endl;
        -:   70:			return false;
        -:   71:		}
        -:   72:
        -:   73:		if (e_ident[EI_CLASS] == ELFCLASS32) {
        -:   74:			// 32-bit ELF
        -:   75:			return this->LoadElfSpecific<Elf32_Ehdr, Elf32_Phdr>(buf.data(), buf_sz);
        -:   76:		}
        -:   77:		else if (e_ident[EI_CLASS] == ELFCLASS64) {
        -:   78:			// 64-bit ELF
        -:   79:			return this->LoadElfSpecific<Elf64_Ehdr, Elf64_Phdr>(buf.data(), buf_sz);
        -:   80:		}
        -:   81:		else {
        -:   82:			std::cerr << "ERROR: load_elf: file is neither 32-bit nor 64-bit" << std::endl;
        -:   83:			return false;
        -:   84:		}
        -:   85:	}
        -:   86:
    #####:   87:	Word Read(Word ip)
        -:   88:	{
    #####:   89:		return _mem[ToWordAddr(ip)];
    %%%%%:   89-block  0
        -:   90:	}
        -:   91:
    #####:   92:	void Write(Word ip, Word data)
        -:   93:	{
    #####:   94:		_mem[ToWordAddr(ip)] = data;
    %%%%%:   94-block  0
    #####:   95:	}
        -:   96:
        -:   97:private:
        -:   98:	template <typename Elf_Ehdr, typename Elf_Phdr>
        -:   99:	bool LoadElfSpecific(char* buf, size_t buf_sz) {
        -:  100:		// 64-bit ELF
        -:  101:		Elf_Ehdr* ehdr = (Elf_Ehdr*)buf;
        -:  102:		Elf_Phdr* phdr = (Elf_Phdr*)(buf + ehdr->e_phoff);
        -:  103:		if (buf_sz < ehdr->e_phoff + ehdr->e_phnum * sizeof(Elf_Phdr)) {
        -:  104:			std::cerr << "ERROR: load_elf: file too small for expected number of program header tables" << std::endl;
        -:  105:			return false;
        -:  106:		}
        -:  107:		auto memptr = reinterpret_cast<char*>(_mem.data());
        -:  108:		// loop through program header tables
        -:  109:		for (int i = 0; i < ehdr->e_phnum; i++) {
        -:  110:			if ((phdr[i].p_type == PT_LOAD) && (phdr[i].p_memsz > 0)) {
        -:  111:				if (phdr[i].p_memsz < phdr[i].p_filesz) {
        -:  112:					std::cerr << "ERROR: load_elf: file size is larger than memory size" << std::endl;
        -:  113:					return false;
        -:  114:				}
        -:  115:				if (phdr[i].p_filesz > 0) {
        -:  116:					if (phdr[i].p_offset + phdr[i].p_filesz > buf_sz) {
        -:  117:						std::cerr << "ERROR: load_elf: file section overflow" << std::endl;
        -:  118:						return false;
        -:  119:					}
        -:  120:
        -:  121:					// start of file section: buf + phdr[i].p_offset
        -:  122:					// end of file section: buf + phdr[i].p_offset + phdr[i].p_filesz
        -:  123:					// start of memory: phdr[i].p_paddr
        -:  124:					std::memcpy(memptr + phdr[i].p_paddr, buf + phdr[i].p_offset, phdr[i].p_filesz);
        -:  125:				}
        -:  126:				if (phdr[i].p_memsz > phdr[i].p_filesz) {
        -:  127:					// copy 0's to fill up remaining memory
        -:  128:					size_t zeros_sz = phdr[i].p_memsz - phdr[i].p_filesz;
        -:  129:					std::memset(memptr + phdr[i].p_paddr + phdr[i].p_filesz, 0, zeros_sz);
        -:  130:				}
        -:  131:			}
        -:  132:		}
        -:  133:		return true;
        -:  134:	}
        -:  135:
        -:  136:	std::vector<Word> _mem;
        -:  137:};
        -:  138:
        -:  139:
        -:  140:class IMem
        -:  141:{
        -:  142:public:
    #####:  143:	IMem() = default;
    #####:  144:	virtual ~IMem() = default;
        -:  145:	IMem(const IMem&) = delete;
        -:  146:	IMem(IMem&&) = delete;
        -:  147:
        -:  148:	IMem& operator=(const IMem&) = delete;
        -:  149:	IMem& operator=(IMem&&) = delete;
        -:  150:
        -:  151:	virtual void Request(Word ip) = 0;
        -:  152:	virtual std::optional<Word> Response() = 0;
        -:  153:	virtual void Request(Word, IType) = 0;
        -:  154:	virtual bool Response(Word, IType, Word&) = 0;
        -:  155:	virtual void Clock() = 0;
        -:  156:};
        -:  157:
        -:  158:
        -:  159:class CachedMem : public IMem
        -:  160:{
        -:  161:public:
        -:  162:
    #####:  163:	explicit CachedMem(MemoryStorage& amem)
    #####:  164:		: _mem(amem)
    %%%%%:  164-block  0
        -:  165:	{
        -:  166:
    #####:  167:	}
        -:  168:
    #####:  169:	void Request(Word ip)
        -:  170:	{
    #####:  171:		_requestedIp = ip;
    #####:  172:		Word tag = ToLineAddr(_requestedIp);
    %%%%%:  172-block  0
    #####:  173:		if (std::find(_code_cache.last_used.begin(), _code_cache.last_used.end(), tag) != _code_cache.last_used.end())
    %%%%%:  173-block  0
    $$$$$:  173-block  1
        -:  174:		{
    #####:  175:			_code_cache.last_used.remove(tag);
    %%%%%:  175-block  0
        -:  176:		}
        -:  177:
        -:  178:		else
        -:  179:		{
    #####:  180:			int i = 0;
    %%%%%:  180-block  0
    #####:  181:			while (i < lineSizeWords) {
    %%%%%:  181-block  0
    #####:  182:				Word word = _mem.Read(tag + i * 4);
    %%%%%:  182-block  0
        -:  183:
    #####:  184:				line[ToLineOffset(tag + i * 4)] = word;
    $$$$$:  184-block  0
    #####:  185:				i++;
    %%%%%:  185-block  0
        -:  186:			}
    #####:  187:			_code_cache.tables[tag] = line;
    %%%%%:  187-block  0
    %%%%%:  187-block  1
        -:  188:
    #####:  189:			if (_code_cache.tables.size() == _code_lines)
    %%%%%:  189-block  0
        -:  190:			{
    #####:  191:				erase_tag = _code_cache.last_used.back();
    %%%%%:  191-block  0
    #####:  192:				_code_cache.last_used.remove(erase_tag);
    #####:  193:				_code_cache.tables.erase(erase_tag);
        -:  194:			}
    #####:  195:			_waitCycles = latency;
    %%%%%:  195-block  0
        -:  196:		}
    #####:  197:		_code_cache.last_used.push_front(tag);
    %%%%%:  197-block  0
        -:  198:
    #####:  199:	}
    %%%%%:  199-block  0
        -:  200:
    #####:  201:	std::optional<Word> Response()
        -:  202:	{
    #####:  203:		if (_waitCycles > 0)
    %%%%%:  203-block  0
    #####:  204:			return std::optional<Word>();
    %%%%%:  204-block  0
    #####:  205:		return _code_cache.tables[ToLineAddr(_requestedIp)][ToLineOffset(_requestedIp)];
    %%%%%:  205-block  0
    %%%%%:  205-block  1
    %%%%%:  205-block  2
    %%%%%:  205-block  3
    $$$$$:  205-block  4
        -:  206:
        -:  207:	}
        -:  208:
    #####:  209:	void Request(Word _addr, IType _type)
        -:  210:	{
    #####:  211:		if (_type != IType::Ld && _type != IType::St)
    %%%%%:  211-block  0
    %%%%%:  211-block  1
        -:  212:		{
    #####:  213:		    skip = true;
    #####:  214:			return;
    %%%%%:  214-block  0
        -:  215:		}
        -:  216:		else {
    #####:  217:			_requestedIp = _addr;
    #####:  218:            Word tag = ToLineAddr(_requestedIp);
    %%%%%:  218-block  0
    #####:  219:			if (std::find(_data_cache.last_used.begin(), _data_cache.last_used.end(), tag) != _data_cache.last_used.end())
    %%%%%:  219-block  0
    $$$$$:  219-block  1
        -:  220:			{
    #####:  221:				_data_cache.last_used.remove(tag);
    %%%%%:  221-block  0
    #####:  222:				_waitCycles += 3;
        -:  223:
        -:  224:			}
        -:  225:
        -:  226:			else
        -:  227:			{
    #####:  228:				int i = 0;
    %%%%%:  228-block  0
    #####:  229:				while (i < lineSizeWords) {
    %%%%%:  229-block  0
    #####:  230:					Word word = _mem.Read(tag + i * 4);
    %%%%%:  230-block  0
    #####:  231:					line[ToLineOffset(tag + i * 4)] = word;
    $$$$$:  231-block  0
    #####:  232:					i++;
    %%%%%:  232-block  0
        -:  233:				}
    #####:  234:				_data_cache.tables[tag] = line;
    %%%%%:  234-block  0
    %%%%%:  234-block  1
        -:  235:
    #####:  236:				if (_data_cache.tables.size() == _data_lines)
    %%%%%:  236-block  0
        -:  237:				{
    #####:  238:					erase_tag = _data_cache.last_used.back();
    %%%%%:  238-block  0
    #####:  239:					_data_cache.last_used.remove(erase_tag);
    #####:  240:					i = 0;
    #####:  241:					while (i < lineSizeWords) {
    %%%%%:  241-block  0
    #####:  242:						_mem.Write(erase_tag + i * 4, _data_cache.tables[erase_tag][ToLineOffset(erase_tag + i * 4)]);
    %%%%%:  242-block  0
    %%%%%:  242-block  1
    %%%%%:  242-block  2
    $$$$$:  242-block  3
    #####:  243:						i++;
        -:  244:					}
    #####:  245:					_data_cache.tables.erase(erase_tag);
    %%%%%:  245-block  0
        -:  246:				}
    #####:  247:				_waitCycles = latency;
    %%%%%:  247-block  0
        -:  248:			}
    #####:  249:			_data_cache.last_used.push_front(tag);
    %%%%%:  249-block  0
        -:  250:		}
    #####:  251:		return;
    %%%%%:  251-block  0
        -:  252:	}
        -:  253:
    #####:  254:	bool Response(Word _addr, IType _type, Word& _data)
        -:  255:	{
    #####:  256:		if (_type != IType::Ld && _type != IType::St)
    %%%%%:  256-block  0
    %%%%%:  256-block  1
    #####:  257:			return true;
    %%%%%:  257-block  0
        -:  258:
    #####:  259:		if (_waitCycles != 0)
    %%%%%:  259-block  0
    #####:  260:			return false;
    %%%%%:  260-block  0
        -:  261:
    #####:  262:		if (_type == IType::Ld) {
    %%%%%:  262-block  0
    #####:  263:            _data = _data_cache.tables[ToLineAddr(_addr)][ToLineOffset(_addr)];
    %%%%%:  263-block  0
    %%%%%:  263-block  1
    $$$$$:  263-block  2
    $$$$$:  263-block  3
    #####:  264:            data = _data;
    %%%%%:  264-block  0
        -:  265:        }
        -:  266:		else
        -:  267:		{
    #####:  268:			_data_cache.tables[ToLineAddr(_addr)][ToLineOffset(_addr)] = _data;
    %%%%%:  268-block  0
    %%%%%:  268-block  1
    $$$$$:  268-block  2
    #####:  269:			_mem.Write(_addr, _data);
    %%%%%:  269-block  0
        -:  270:		}
    #####:  271:		return true;
    %%%%%:  271-block  0
        -:  272:	}
        -:  273:
        -:  274:
    #####:  275:	void Clock()
        -:  276:	{
    #####:  277:		if (_waitCycles > 0)
    %%%%%:  277-block  0
    #####:  278:			_waitCycles = 0;
    %%%%%:  278-block  0
    #####:  279:	}
        -:  280:
        -:  281:    size_t getWaitCycles()
        -:  282:    {
        -:  283:        return _waitCycles;
        -:  284:    }
        -:  285:
        5:  286:    void setWaitCycles(size_t waitCycles) {
        5:  287:        _waitCycles = waitCycles;
        5:  288:    }
        -:  289:
        -:  290:
        -:  291:    std::list<Word> getCodeList() const {
        -:  292:        return _code_cache.last_used;
        -:  293:    }
        -:  294:
        -:  295:
        -:  296:    bool getSkip() const {
        -:  297:        return skip;
        -:  298:    }
        -:  299:
        1:  300:    void setCacheCodeTableLines(Word ip, std::map<Word, Word> custom_line) {
        1:  301:        _requestedIp = ip;
        1:  302:        Word tag = ToLineAddr(_requestedIp);
        1:  302-block  0
        1:  303:        _code_cache.tables[tag] = custom_line;
        1:  303-block  0
        1:  304:    }
        1:  304-block  0
        -:  305:
        -:  306:    void setCacheDataTableLines(Word ip, std::map<Word, Word> custom_line){
        -:  307:        _requestedIp = ip;
        -:  308:        Word tag = ToLineAddr(_requestedIp);
        -:  309:        _data_cache.tables[tag] = custom_line;
        -:  310:    }
        -:  311:
        -:  312:
        2:  313:    void setCacheCodeLastUsed(Word ip) {
        2:  314:        _requestedIp = ip;
        2:  315:        Word tag = ToLineAddr(_requestedIp);
        2:  315-block  0
        2:  316:        _code_cache.last_used.push_front(tag);
        2:  317:    }
        2:  317-block  0
        -:  318:
        -:  319:    void setCacheDataLastUsed(Word ip){
        -:  320:        _requestedIp = ip;
        -:  321:        Word tag = ToLineAddr(_requestedIp);
        -:  322:        _data_cache.last_used.push_front(tag);
        -:  323:	}
        -:  324:
        -:  325:    std::map<Word, Word> getLine() const {
        -:  326:        return line;
        -:  327:    }
        -:  328:
        -:  329:    Word getEraseTag() const {
        -:  330:        return erase_tag;
        -:  331:    }
        -:  332:
        -:  333:    std::map<Word, std::map<Word, Word>> getDataTables(){
        -:  334:        return _data_cache.tables;
        -:  335:    }
        -:  336:
        -:  337:	Word getData(){
        -:  338:	    return data;
        -:  339:	}
        -:  340:
        -:  341:private:
        -:  342:	static constexpr size_t latency = 136;
        -:  343:	Word data = 0;
        -:  344:    Word erase_tag = 0;
        -:  345:	Word _requestedIp = 0;
        -:  346:	size_t _waitCycles = 0;
        -:  347:	MemoryStorage& _mem;
        -:  348:	const int _data_lines = 64;  // 4096 / 64
        -:  349:	const int _code_lines = 8;  // 512 / 64
        -:  350:	std::map<Word, Word> line;
        -:  351:
        -:  352:
        -:  353:    bool skip = false;
        -:  354:    
        -:  355:	struct Cache
        -:  356:	{
        -:  357:		std::list<Word> last_used;
        -:  358:		std::map<Word, std::map<Word, Word>> tables;
        -:  359:	};
        -:  360:	Cache _code_cache;
        -:  361:	Cache _data_cache;
        -:  362:
        -:  363:};
        -:  364:
        -:  365:#endif //RISCV_SIM_DATAMEMORY_H
