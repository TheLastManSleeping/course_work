        -:    0:Source:/home/Arter/ABC2/src/Memory.h
        -:    0:Graph:/home/Arter/ABC2/Google_tests/CMakeFiles/Google_Tests_run.dir/code_request_test.cpp.gcno
        -:    0:Data:/home/Arter/ABC2/Google_tests/CMakeFiles/Google_Tests_run.dir/code_request_test.cpp.gcda
        -:    0:Runs:1
        -:    1:
        -:    2:#ifndef RISCV_SIM_DATAMEMORY_H
        -:    3:#define RISCV_SIM_DATAMEMORY_H
        -:    4:
        -:    5:#include "Instruction.h"
        -:    6:#include <iostream>
        -:    7:#include <fstream>
        -:    8:#include <elf.h>
        -:    9:#include <cstring>
        -:   10:#include <vector>
        -:   11:#include <cassert>
        -:   12:#include <map>
        -:   13:#include <list>
        -:   14:#include <algorithm>
        -:   15:
        -:   16:
        -:   17://static constexpr size_t memSize = 4*1024*1024; // memory size in 4-byte words
        -:   18:static constexpr size_t memSize = 1024 * 1024; // memory size in 4-byte words
        -:   19:
        -:   20:static constexpr size_t lineSizeBytes = 64;
        -:   21:static constexpr size_t lineSizeWords = lineSizeBytes / sizeof(Word);
        -:   22:using Line = std::array<Word, lineSizeWords>;
     2395:   23:static Word ToWordAddr(Word addr) { return addr >> 2u; }
     2395:   23-block  0
       81:   24:static Word ToLineAddr(Word addr) { return addr & ~(lineSizeBytes - 1); }
       81:   24-block  0
     1187:   25:static Word ToLineOffset(Word addr) { return ToWordAddr(addr) & (lineSizeWords - 1); }
     1187:   25-block  0
        -:   26:
        -:   27:class MemoryStorage {
        -:   28:public:
        -:   29:
       12:   30:	MemoryStorage()
       12:   31:	{
       12:   31-block  0
    $$$$$:   31-block  1
       12:   32:		_mem.resize(memSize);
       12:   33:	}
       12:   33-block  0
        -:   34:
        -:   35:	bool LoadElf(const std::string& elf_filename) {
        -:   36:		std::ifstream elffile;
        -:   37:		elffile.open(elf_filename, std::ios::in | std::ios::binary);
        -:   38:
        -:   39:		if (!elffile.is_open()) {
        -:   40:			std::cerr << "ERROR: load_elf: failed opening file \"" << elf_filename << "\"" << std::endl;
        -:   41:			return false;
        -:   42:		}
        -:   43:
        -:   44:		elffile.seekg(0, elffile.end);
        -:   45:		size_t buf_sz = elffile.tellg();
        -:   46:		elffile.seekg(0, elffile.beg);
        -:   47:
        -:   48:		// Read the entire file. If it doesn't fit in host memory, it won't fit in the risc-v processor
        -:   49:		std::vector<char> buf(buf_sz);
        -:   50:		elffile.read(buf.data(), buf_sz);
        -:   51:
        -:   52:		if (!elffile) {
        -:   53:			std::cerr << "ERROR: load_elf: failed reading elf header" << std::endl;
        -:   54:			return false;
        -:   55:		}
        -:   56:
        -:   57:		if (buf_sz < sizeof(Elf32_Ehdr)) {
        -:   58:			std::cerr << "ERROR: load_elf: file too small to be a valid elf file" << std::endl;
        -:   59:			return false;
        -:   60:		}
        -:   61:
        -:   62:		// make sure the header matches elf32 or elf64
        -:   63:		Elf32_Ehdr* ehdr = (Elf32_Ehdr*)buf.data();
        -:   64:		unsigned char* e_ident = ehdr->e_ident;
        -:   65:		if (e_ident[EI_MAG0] != ELFMAG0
        -:   66:			|| e_ident[EI_MAG1] != ELFMAG1
        -:   67:			|| e_ident[EI_MAG2] != ELFMAG2
        -:   68:			|| e_ident[EI_MAG3] != ELFMAG3) {
        -:   69:			std::cerr << "ERROR: load_elf: file is not an elf file" << std::endl;
        -:   70:			return false;
        -:   71:		}
        -:   72:
        -:   73:		if (e_ident[EI_CLASS] == ELFCLASS32) {
        -:   74:			// 32-bit ELF
        -:   75:			return this->LoadElfSpecific<Elf32_Ehdr, Elf32_Phdr>(buf.data(), buf_sz);
        -:   76:		}
        -:   77:		else if (e_ident[EI_CLASS] == ELFCLASS64) {
        -:   78:			// 64-bit ELF
        -:   79:			return this->LoadElfSpecific<Elf64_Ehdr, Elf64_Phdr>(buf.data(), buf_sz);
        -:   80:		}
        -:   81:		else {
        -:   82:			std::cerr << "ERROR: load_elf: file is neither 32-bit nor 64-bit" << std::endl;
        -:   83:			return false;
        -:   84:		}
        -:   85:	}
        -:   86:
     1185:   87:	Word Read(Word ip)
        -:   88:	{
     1185:   89:		return _mem[ToWordAddr(ip)];
     1185:   89-block  0
        -:   90:	}
        -:   91:
       23:   92:	void Write(Word ip, Word data)
        -:   93:	{
       23:   94:		_mem[ToWordAddr(ip)] = data;
       23:   94-block  0
       23:   95:	}
        -:   96:
        -:   97:private:
        -:   98:	template <typename Elf_Ehdr, typename Elf_Phdr>
        -:   99:	bool LoadElfSpecific(char* buf, size_t buf_sz) {
        -:  100:		// 64-bit ELF
        -:  101:		Elf_Ehdr* ehdr = (Elf_Ehdr*)buf;
        -:  102:		Elf_Phdr* phdr = (Elf_Phdr*)(buf + ehdr->e_phoff);
        -:  103:		if (buf_sz < ehdr->e_phoff + ehdr->e_phnum * sizeof(Elf_Phdr)) {
        -:  104:			std::cerr << "ERROR: load_elf: file too small for expected number of program header tables" << std::endl;
        -:  105:			return false;
        -:  106:		}
        -:  107:		auto memptr = reinterpret_cast<char*>(_mem.data());
        -:  108:		// loop through program header tables
        -:  109:		for (int i = 0; i < ehdr->e_phnum; i++) {
        -:  110:			if ((phdr[i].p_type == PT_LOAD) && (phdr[i].p_memsz > 0)) {
        -:  111:				if (phdr[i].p_memsz < phdr[i].p_filesz) {
        -:  112:					std::cerr << "ERROR: load_elf: file size is larger than memory size" << std::endl;
        -:  113:					return false;
        -:  114:				}
        -:  115:				if (phdr[i].p_filesz > 0) {
        -:  116:					if (phdr[i].p_offset + phdr[i].p_filesz > buf_sz) {
        -:  117:						std::cerr << "ERROR: load_elf: file section overflow" << std::endl;
        -:  118:						return false;
        -:  119:					}
        -:  120:
        -:  121:					// start of file section: buf + phdr[i].p_offset
        -:  122:					// end of file section: buf + phdr[i].p_offset + phdr[i].p_filesz
        -:  123:					// start of memory: phdr[i].p_paddr
        -:  124:					std::memcpy(memptr + phdr[i].p_paddr, buf + phdr[i].p_offset, phdr[i].p_filesz);
        -:  125:				}
        -:  126:				if (phdr[i].p_memsz > phdr[i].p_filesz) {
        -:  127:					// copy 0's to fill up remaining memory
        -:  128:					size_t zeros_sz = phdr[i].p_memsz - phdr[i].p_filesz;
        -:  129:					std::memset(memptr + phdr[i].p_paddr + phdr[i].p_filesz, 0, zeros_sz);
        -:  130:				}
        -:  131:			}
        -:  132:		}
        -:  133:		return true;
        -:  134:	}
        -:  135:
        -:  136:	std::vector<Word> _mem;
        -:  137:};
        -:  138:
        -:  139:
        -:  140:class IMem
        -:  141:{
        -:  142:public:
       12:  143:	IMem() = default;
       12:  144:	virtual ~IMem() = default;
        -:  145:	IMem(const IMem&) = delete;
        -:  146:	IMem(IMem&&) = delete;
        -:  147:
        -:  148:	IMem& operator=(const IMem&) = delete;
        -:  149:	IMem& operator=(IMem&&) = delete;
        -:  150:
        -:  151:	virtual void Request(Word ip) = 0;
        -:  152:	virtual std::optional<Word> Response() = 0;
        -:  153:	virtual void Request(Word, IType) = 0;
        -:  154:	virtual bool Response(Word, IType, Word&) = 0;
        -:  155:	virtual void Clock() = 0;
        -:  156:};
        -:  157:
        -:  158:
        -:  159:class CachedMem : public IMem
        -:  160:{
        -:  161:public:
        -:  162:
       12:  163:	explicit CachedMem(MemoryStorage& amem)
       12:  164:		: _mem(amem)
       12:  164-block  0
        -:  165:	{
        -:  166:
       12:  167:	}
        -:  168:
       10:  169:	void Request(Word ip)
        -:  170:	{
       10:  171:		_requestedIp = ip;
       10:  172:		Word tag = ToLineAddr(_requestedIp);
       10:  172-block  0
       10:  173:		if (std::find(_code_cache.last_used.begin(), _code_cache.last_used.end(), tag) != _code_cache.last_used.end())
       10:  173-block  0
    $$$$$:  173-block  1
        -:  174:		{
        1:  175:			_code_cache.last_used.remove(tag);
        1:  175-block  0
        -:  176:		}
        -:  177:
        -:  178:		else
        -:  179:		{
        9:  180:			int i = 0;
        9:  180-block  0
      153:  181:			while (i < lineSizeWords) {
      153:  181-block  0
      144:  182:				Word word = _mem.Read(tag + i * 4);
      144:  182-block  0
        -:  183:
      144:  184:				line[ToLineOffset(tag + i * 4)] = word;
    $$$$$:  184-block  0
      144:  185:				i++;
      144:  185-block  0
        -:  186:			}
        9:  187:			_code_cache.tables[tag] = line;
        9:  187-block  0
        9:  187-block  1
        -:  188:
        9:  189:			if (_code_cache.tables.size() == _code_lines)
        9:  189-block  0
        -:  190:			{
        1:  191:				erase_tag = _code_cache.last_used.back();
        1:  191-block  0
        1:  192:				_code_cache.last_used.remove(erase_tag);
        1:  193:				_code_cache.tables.erase(erase_tag);
        -:  194:			}
        9:  195:			_waitCycles = latency;
        9:  195-block  0
        -:  196:		}
       10:  197:		_code_cache.last_used.push_front(tag);
       10:  197-block  0
        -:  198:
       10:  199:	}
       10:  199-block  0
        -:  200:
        2:  201:	std::optional<Word> Response()
        -:  202:	{
        2:  203:		if (_waitCycles > 0)
        2:  203-block  0
        1:  204:			return std::optional<Word>();
        1:  204-block  0
        1:  205:		return _code_cache.tables[ToLineAddr(_requestedIp)][ToLineOffset(_requestedIp)];
        1:  205-block  0
        1:  205-block  1
        1:  205-block  2
        1:  205-block  3
    $$$$$:  205-block  4
        -:  206:
        -:  207:	}
        -:  208:
       68:  209:	void Request(Word _addr, IType _type)
        -:  210:	{
       68:  211:		if (_type != IType::Ld && _type != IType::St)
       68:  211-block  0
        2:  211-block  1
        -:  212:		{
        1:  213:		    skip = true;
        1:  214:			return;
        1:  214-block  0
        -:  215:		}
        -:  216:		else {
       67:  217:			_requestedIp = _addr;
       67:  218:            Word tag = ToLineAddr(_requestedIp);
       67:  218-block  0
       67:  219:			if (std::find(_data_cache.last_used.begin(), _data_cache.last_used.end(), tag) != _data_cache.last_used.end())
       67:  219-block  0
    $$$$$:  219-block  1
        -:  220:			{
        3:  221:				_data_cache.last_used.remove(tag);
        3:  221-block  0
        3:  222:				_waitCycles += 3;
        -:  223:
        -:  224:			}
        -:  225:
        -:  226:			else
        -:  227:			{
       64:  228:				int i = 0;
       64:  228-block  0
     1088:  229:				while (i < lineSizeWords) {
     1088:  229-block  0
     1024:  230:					Word word = _mem.Read(tag + i * 4);
     1024:  230-block  0
     1024:  231:					line[ToLineOffset(tag + i * 4)] = word;
    $$$$$:  231-block  0
     1024:  232:					i++;
     1024:  232-block  0
        -:  233:				}
       64:  234:				_data_cache.tables[tag] = line;
       64:  234-block  0
       64:  234-block  1
        -:  235:
       64:  236:				if (_data_cache.tables.size() == _data_lines)
       64:  236-block  0
        -:  237:				{
        1:  238:					erase_tag = _data_cache.last_used.back();
        1:  238-block  0
        1:  239:					_data_cache.last_used.remove(erase_tag);
        1:  240:					i = 0;
       17:  241:					while (i < lineSizeWords) {
       17:  241-block  0
       16:  242:						_mem.Write(erase_tag + i * 4, _data_cache.tables[erase_tag][ToLineOffset(erase_tag + i * 4)]);
       16:  242-block  0
       16:  242-block  1
       16:  242-block  2
    $$$$$:  242-block  3
       16:  243:						i++;
        -:  244:					}
        1:  245:					_data_cache.tables.erase(erase_tag);
        1:  245-block  0
        -:  246:				}
       64:  247:				_waitCycles = latency;
       64:  247-block  0
        -:  248:			}
       67:  249:			_data_cache.last_used.push_front(tag);
       67:  249-block  0
        -:  250:		}
       67:  251:		return;
       67:  251-block  0
        -:  252:	}
        -:  253:
        4:  254:	bool Response(Word _addr, IType _type, Word& _data)
        -:  255:	{
        4:  256:		if (_type != IType::Ld && _type != IType::St)
        4:  256-block  0
        3:  256-block  1
        1:  257:			return true;
        1:  257-block  0
        -:  258:
        3:  259:		if (_waitCycles != 0)
        3:  259-block  0
        1:  260:			return false;
        1:  260-block  0
        -:  261:
        2:  262:		if (_type == IType::Ld) {
        2:  262-block  0
        1:  263:            _data = _data_cache.tables[ToLineAddr(_addr)][ToLineOffset(_addr)];
        1:  263-block  0
        1:  263-block  1
    $$$$$:  263-block  2
    $$$$$:  263-block  3
        1:  264:            data = _data;
        1:  264-block  0
        -:  265:        }
        -:  266:		else
        -:  267:		{
        1:  268:			_data_cache.tables[ToLineAddr(_addr)][ToLineOffset(_addr)] = _data;
        1:  268-block  0
        1:  268-block  1
    $$$$$:  268-block  2
        1:  269:			_mem.Write(_addr, _data);
        1:  269-block  0
        -:  270:		}
        2:  271:		return true;
        2:  271-block  0
        -:  272:	}
        -:  273:
        -:  274:
        1:  275:	void Clock()
        -:  276:	{
        1:  277:		if (_waitCycles > 0)
        1:  277-block  0
        1:  278:			_waitCycles = 0;
        1:  278-block  0
        1:  279:	}
        -:  280:
        4:  281:    size_t getWaitCycles()
        -:  282:    {
        4:  283:        return _waitCycles;
        4:  283-block  0
        -:  284:    }
        -:  285:
        -:  286:    void setWaitCycles(size_t waitCycles) {
        -:  287:        _waitCycles = waitCycles;
        -:  288:    }
        -:  289:
        -:  290:
        2:  291:    std::list<Word> getCodeList() const {
        2:  292:        return _code_cache.last_used;
        2:  292-block  0
        -:  293:    }
        -:  294:
        -:  295:
        -:  296:    bool getSkip() const {
        -:  297:        return skip;
        -:  298:    }
        -:  299:
        -:  300:    void setCacheCodeTableLines(Word ip, std::map<Word, Word> custom_line) {
        -:  301:        _requestedIp = ip;
        -:  302:        Word tag = ToLineAddr(_requestedIp);
        -:  303:        _code_cache.tables[tag] = custom_line;
        -:  304:    }
        -:  305:
        -:  306:    void setCacheDataTableLines(Word ip, std::map<Word, Word> custom_line){
        -:  307:        _requestedIp = ip;
        -:  308:        Word tag = ToLineAddr(_requestedIp);
        -:  309:        _data_cache.tables[tag] = custom_line;
        -:  310:    }
        -:  311:
        -:  312:
        -:  313:    void setCacheCodeLastUsed(Word ip) {
        -:  314:        _requestedIp = ip;
        -:  315:        Word tag = ToLineAddr(_requestedIp);
        -:  316:        _code_cache.last_used.push_front(tag);
        -:  317:    }
        -:  318:
        -:  319:    void setCacheDataLastUsed(Word ip){
        -:  320:        _requestedIp = ip;
        -:  321:        Word tag = ToLineAddr(_requestedIp);
        -:  322:        _data_cache.last_used.push_front(tag);
        -:  323:	}
        -:  324:
        2:  325:    std::map<Word, Word> getLine() const {
        2:  326:        return line;
        2:  326-block  0
        -:  327:    }
        -:  328:
        2:  329:    Word getEraseTag() const {
        2:  330:        return erase_tag;
        2:  330-block  0
        -:  331:    }
        -:  332:
        -:  333:    std::map<Word, std::map<Word, Word>> getDataTables(){
        -:  334:        return _data_cache.tables;
        -:  335:    }
        -:  336:
        -:  337:	Word getData(){
        -:  338:	    return data;
        -:  339:	}
        -:  340:
        -:  341:private:
        -:  342:	static constexpr size_t latency = 136;
        -:  343:	Word data = 0;
        -:  344:    Word erase_tag = 0;
        -:  345:	Word _requestedIp = 0;
        -:  346:	size_t _waitCycles = 0;
        -:  347:	MemoryStorage& _mem;
        -:  348:	const int _data_lines = 64;  // 4096 / 64
        -:  349:	const int _code_lines = 8;  // 512 / 64
        -:  350:	std::map<Word, Word> line;
        -:  351:
        -:  352:
        -:  353:    bool skip = false;
        -:  354:    
        -:  355:	struct Cache
        -:  356:	{
        -:  357:		std::list<Word> last_used;
        -:  358:		std::map<Word, std::map<Word, Word>> tables;
        -:  359:	};
        -:  360:	Cache _code_cache;
        -:  361:	Cache _data_cache;
        -:  362:
        -:  363:};
        -:  364:
        -:  365:#endif //RISCV_SIM_DATAMEMORY_H
